<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次React Native远程调试，解决只在千里之外可重现的Bug。]]></title>
    <url>%2F2017%2F08%2F06%2Freact-native-remote-debug%2F</url>
    <content type="text"><![CDATA[前言这篇文章的主要内容有两个： React Native如何调试不在局域网内的设备、如何把这些设备变成在局域网内方便地调试（无论设备在4G还是Wifi的情况下） 深坑提醒：截止到发稿前华为P10最新版本系统 EMUI5.0 (Android 7.0），Style Sheet中的transform属性失效了 故事的起因一天，老师过来跟我说，咱们App聊天模块里面的列表，在一台华为P10手机上面显示不出来，它能发消息，别人也能看到它发的消息，但是它却连自己发的消息也看不到，是个必现的问题，让我查查这是什么幺蛾子。 嗯，这台手机不在我们这，在分公司同事手里，搞不定就自己去出差吧。😀 分析问题首先想到：服务端的锅由于我们聊天列表的数据，客户端是不保存的，这份数据由服务端维护，客户端订阅上后，服务端会给客户端返回指定数据，于是让服务端的哥们帮忙调试，经过一轮紧张忙碌的调试，最后他告诉我：“我不知道，我这里是好的”。（老板，这只是个梗，咱们团队都是负责到底的哈哈哈） 既然如此，为了证明服务端哥们这轮调试的结论是对的，我想我最好能看这台远程手机上面的Log信息，甚至打断点去debug，看看客户端出了什么问题。 提出设想由于React Native本身就支持Debug JS Remotely，所以首先想到的，肯定是把我的机器配置到外网，然后让分公司的同事连接到我机器上就能进行调试；其本地的npm服务将会加载node_modules，然后提供8081端口给debug包的app进行请求，最终做到了动态把js代码传输到debug包的程序上。 Just do it.有了这个想法之后，就去找运维同学，一波操作过后，我的电脑已经可以在公网上进行访问了，二话不说，就是干： 提取debug apk: 当前项目下，找到 “android/app/build/outputs/apk/app-debug.apk”，如果修改过项目模块名称，自己去找回对应的路径，相信这个不会有难度；在React Native项目中，这个debug包跟release包最大的区别是：release包已经打包好了所有.js文件到assets目录中，而debug包是通过请求加载本项目js代码的npm服务来动态加载js文件； 安装debug包，运行debug程序后，在 “Dev Settings” 中设置 “Debug server host &amp; port for device” ，地址修改为自己电脑的公网ip，端口8081； 在调试菜单中，选择 “Debug JS Remotely”。 接下来当然就是最激动人心的时刻啦，同事的机器顺利地连上了我电脑本地的npm服务，我和运维小哥四目相视，会心一笑。然而，事情总是出乎意料，命运也喜欢捉弄人，一下秒，妹子同事说手机红屏了，在我的Chrome调试页面中打印了一行： 123Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'http://localhost:8082/create_session' Realm failed to connect to the embedded debug server inside the app. If attempting to use Chrome debugging from a device, ensure the device is reachable on the same network as this machine. 惊不惊喜，意不意外？ 咋一看，似乎问题不大，再把我机器的8082端口打开，是不是应该就可以了？然而，事情总是出乎意料，命运也喜欢捉弄人。X妹子说，还是一样耶。然后，我在realm-js的项目下找到了这个issues: https://github.com/realm/realm-js/issues/284，这个issues已经是closed状态，但是可能因为我在非局域网调试的原因，升级到最新版本的realm-js，仍然存在。此时，默默说了一句WTF之后，我感觉整个人垮掉了。 WTF之后的思考注意到错误提示中的 “ensure the device is reachable on the same network as this machine” ，我又有了一个大胆的想法：让该同事的手机，跟我的电脑在同一个网段。 这…似乎还真有这么一种操作，这个世界上，有一种叫 “Virtual Private Network” 的东西（和谐和谐），假设我的电脑和该同事的手机，同时连接上我们自己的代理服务器，通过这个代理的地址，似乎就可以实现 “在同一个网段” 这个需求。 电脑连接上代理后，会再分配一个地址，Mac上使用ifconfig命令查看 (Win ipconfig)：下面这一波操作就很稳了，我们终于顺利连接到了X同时的手机，可以看到Log，也看到打断点，甚至在4G下都可以调试： 手机电脑都连上代理 在 “Dev Settings” 中设置 “Debug server host &amp; port for device”，修改为上面的代理地址（ipsec0遮挡部分） 在调试菜单中，选择 “Debug JS Remotely”。 解决问题到了这一步，我已经能够看到Log以及打断点进行调试，最后得出的结论是：“服务端的调试结论的确是正确，数据已经顺利拿到了，而是是正确的，长连接也没有问题”。到这里已经可以确认是客户端的锅，而且是这个页面的ListView组件的锅，因为都是用React Native的ListView，为什么其它页面没有问题？ 再次分析React Native 的 ListView 是基于 ScrollView 组件实现的，显示部分异常，应该是ListView里面的ScrollView出了问题，对比其它模块用的 ListView ，发现了一个十分可疑的地方：ListView 组件提供的 “renderScrollComponent” 属性，关于这个这个属性，官方文档是这样说的： renderScrollComponent function (props) =&gt; renderable 指定一个函数，在其中返回一个可以滚动的组件。ListView将会在该组件内部进行渲染。默认情况下会返回一个包含指定属性的ScrollView。 简单说，这个属性可以让我们自定义ListView的滚动组件，如果不设置的话，就是一个默认的ScrollView作为ListView的滚动组件。 很不凑巧，我们指定了这个属性，因为对于聊天列表，最新的消息内容需要显示在列表的最下方，于是我们使用 react-native-invertible-scroll-view 这个第三方库，将这个默认的ScrollView翻转了过来，实现了新消息一直在底部，有新消息也直接滚动到最底部这样的效果（类似：react-native-gifted-chat）。 证实猜想要证明上面的猜想很简单，直接去掉ListView中指定的的 renderScrollComponent 方法，然后刷新界面。X同事说：“显示出来了，不过方向是反的”。 解决问题我们看看这个库是如何将ScrollView翻转过来的，找到核心文件 ‘InvertibleScrollView.js’ ，看到关键代码： 1234567891011121314let styles = StyleSheet.create(&#123; verticallyInverted: &#123; flex: 1, transform: [ &#123; scaleY: -1 &#125;, ], &#125;, horizontallyInverted: &#123; flex: 1, transform: [ &#123; scaleX: -1 &#125;, ], &#125;,&#125;); 到这里已经一切了然，这货使用 transform 属性，在垂直/水平方向上翻转分别使用： 123transform: [ &#123; scaleY: -1 &#125; ] //垂直翻转 transform: [ &#123; scaleX: -1 &#125; ] //水平翻转 到这里已经确诊了，transform 在P10上出问题了，这个问题也可以在 React Native 的 issues 上找到： react-native-invertible-scroll-view not working on Huawei Android 7 devices. always set camera distance on transforms, to default 1280 if 0 目前已经确认有问题的机型如下： FRD-AL10（honor 8） EMUI:5.0 android: 7.0MHA-AL00(Mate9) EMUI:5.0 android:7.0Huawei P10 VTR-L09, EMUI:5.0 Android 7.0 解决方法有两种：1）在transform中增加 perspective: 1280 (在我的项目里没有起效，基于 React Native 0.35) 1transform: [ &#123; scaleY: -1, perspective: 1280 &#125; ] 2）对于Android，使用过时的 {scaleY: -1} 属性，而不是 transform: [ { scaleY: -1 } ]，iOS保持不变 12345678910let styles = StyleSheet.create(&#123; verticallyInverted: Platform.select(&#123; ios: &#123;transform: [&#123;scaleY: -1&#125;]&#125;, android: &#123;scaleY: -1&#125;, &#125;), horizontallyInverted: Platform.select(&#123; ios: &#123;transform: [&#123;scaleX: -1&#125;]&#125;, android: &#123;scaleX: -1&#125;, &#125;),&#125;); 最后附上修复好的翻转ScrollView: V1sk/react-native-invertible-scroll-view 结语这一波调试过程十分曲折，希望大家不会遇到这些奇葩问题。另外，评论系统又GG了，继多说停止服务之后，网易云跟帖也停了，评论数据也清了，现在唯有用Disqus了，也是需要 Virtual Private Network 才能看到评论系统哟~]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>React Native技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧用Android多进程，微信，微博等主流App都在用]]></title>
    <url>%2F2017%2F02%2F26%2FAIDL%2F</url>
    <content type="text"><![CDATA[前言对于进程的概念，来到这里的都是编程修仙之人，就不再啰嗦了，相信大家倒着、跳着、躺着、各种姿势都能背出来。 为什么要使用多进程，一个进程不就可以了吗？相信很多同学在实际开发中，基本都不会去给app划分进程，而且，在Android中使用多进程，还可能需要编写额外的进程通讯代码，还可能带来额外的Bug，这无疑加大了开发的工作量，在很多创业公司中工期也不允许，这导致了整个app都在一个进程中。 整个app都在一个进程有什么弊端？在Android中，虚拟机分配给各个进程的运行内存是有限制值的（这个值可以是32M，48M，64M等，根据机型而定），试想一下，如果在app中，增加了一个很常用的图片选择模块用于上传图片或者头像，加载大量Bitmap会使app的内存占用迅速增加，如果你还把查看过的图片缓存在了内存中，那么OOM的风险将会大大增加，如果此时还需要使用WebView加载一波网页，我就问你怕不怕！ 微信，微博等主流app是如何解决这些问题的？微信移动开发团队在 《Android内存优化杂谈》 一文中就说到：“对于webview，图库等，由于存在内存系统泄露或者占用内存过多的问题，我们可以采用单独的进程。微信当前也会把它们放在单独的tools进程中”。 下面我们使用adb查看一下微信和微博的进程信息（Android 5.0以下版本可直接在“设置 -&gt; 应用程序”相关条目中查看）： 进入adb shell后，使用 “ps | grep 条目名称” 可以过滤出想要查看的进程。可以看到，微信的确有一个tools进程，而新浪微博也有image相关的进程，而且它们当中还有好些其它的进程，比如微信的push进程，微博的remote进程等，这里可以看出，他们不单单只是把上述的WebView、图库等放到单独的进程，还有推送服务等也是运行在独立的进程中的。一个消息推送服务，为了保证稳定性，可能需要和UI进程分离，分离后即使UI进程退出、Crash或者出现内存消耗过高等情况，仍不影响消息推送服务。 可见，合理使用多进程不仅仅是有多大好处的问题，我个人认为而且是很有必要的。 所以说，我们最好还是根据自身情况，考虑一下是否需要拆分进程。这也是本文的初衷：给大家提供一个多进程的参考思路，在遇到上述问题和场景的时候，可以考虑用多进程的方法来解决问题，又或者，在面试的时候，跟面试官聊到这方面的知识时候也不至于尴尬。 为什么需要“跨进程通讯”？Android的进程与进程之间通讯，有些不需要我们额外编写通讯代码，例如：把选择图片模块放到独立的进程，我们仍可以使用startActivityForResult方法，将选中的图片放到Bundle中，使用Intent传递即可。（看到这里，你还不打算把你项目的图片选择弄到独立进程么？） 但是对于把“消息推送Service”放到独立的进程，这个业务就稍微复杂点了，这个时候可能会发生Activity跟Service传递对象，调用Service方法等一系列复杂操作。 由于各个进程运行在相对独立的内存空间，所以它们是不能直接通讯的，因为程序里的变量、对象等初始化后都是具有内存地址的，举个简单的例子，读取一个变量的值，本质是找到变量的内存地址，取出存放的值。不同的进程，运行在相互独立的内存（其实就可以理解为两个不同的应用程序），显然不能直接得知对方变量、对象的内存地址，这样的话也自然不能访问对方的变量，对象等。此时两个进程进行交互，就需要使用跨进程通讯的方式去实现。简单说，跨进程通讯就是一种让进程与进程之间可以进行交互的技术。 跨进程通讯的方式有哪些？ 四大组件间传递Bundle; 使用文件共享方式，多进程读写一个相同的文件，获取文件内容进行交互； 使用Messenger，一种轻量级的跨进程通讯方案，底层使用AIDL实现（实现比较简单，博主开始本文前也想了一下是否要说一下这个东西，最后还是觉得没有这个必要，Google一下就能解决的问题，就不啰嗦了）； 使用AIDL(Android Interface Definition Language)，Android接口定义语言，用于定义跨进程通讯的接口； 使用ContentProvider，常用于多进程共享数据，比如系统的相册，音乐等，我们也可以通过ContentProvider访问到； 使用Socket传输数据。 接下来本文将重点介绍使用AIDL进行多进程通讯，因为AIDL是Android提供给我们的标准跨进程通讯API，非常灵活且强大（貌似面试也经常会问到，但是真正用到的也不多…）。上面所说的Messenger也是使用AIDL实现的一种跨进程方式，Messenger顾名思义，就像是一种串行的消息机制，它是一种轻量级的IPC方案，可以在不同进程中传递Message对象，我们在Message中放入需要传递的数据即可轻松实现进程间通讯。但是当我们需要调用服务端方法，或者存在并发请求，那么Messenger就不合适了。而四大组件传递Bundle，这个就不需要解释了，把需要传递的数据，用Intent封装起来传递即可，其它方式不在本文的讨论范围。 下面开始对AIDL的讲解，各位道友准备好渡劫了吗？ 使用AIDL实现一个多进程消息推送像图片选择这样的多进程需求，可能并不需要我们额外编写进程通讯的代码，使用四大组件传输Bundle就行了，但是像推送服务这种需求，进程与进程之间需要高度的交互，此时就绕不过进程通讯这一步了。下面我们就用即时聊天软件为例，手动去实现一个多进程的推送例子，具体需求如下： UI和消息推送的Service分两个进程； UI进程用于展示具体的消息数据，把用户发送的消息，传递到消息Service，然后发送到远程服务器； Service负责收发消息，并和远程服务器保持长连接，UI进程可通过Service发送消息到远程服务器，Service收到远程服务器消息通知UI进程； 即使UI进程退出了，Service仍需要保持运行，收取服务器消息。 实现思路先来整理一下实现思路： 创建UI进程（下文统称为客户端）； 创建消息Service（下文统称为服务端）； 把服务端配置到独立的进程(AndroidManifest.xml中指定process标签)； 客户端和服务端进行绑定（bindService）； 让客户端和服务端具备交互的能力。(AIDL使用) 例子具体实现为了阅读方便，下文中代码将省略非重点部分，可以把本文完整代码Clone到本地再看文章：https://github.com/V1sk/AIDL Step0. AIDL调用流程概览开始之前，我们先来概括一下使用AIDL进行多进程调用的整个流程： 客户端使用bindService方法绑定服务端； 服务端在onBind方法返回Binder对象； 客户端拿到服务端返回的Binder对象进行跨进程方法调用；整个AIDL调用过程概括起来就以上3个步骤，下文中我们使用上面描述的例子，来逐步分解这些步骤，并讲述其中的细节。 Step1.客户端使用bindService方法绑定服务端1.1 创建客户端和服务端，把服务端配置到另外的进程 创建客户端 -&gt; MainActivity； 创建服务端 -&gt; MessageService; 把服务端配置到另外的进程 -&gt; android:process=”:remote” 上面描述的客户端、服务端、以及把服务端配置到另外进程，体现在AndroidManifest.xml中，如下所示： 12345678910111213&lt;manifest ...&gt; &lt;application ...&gt; &lt;activity android:name=".ui.MainActivity"/&gt; &lt;service android:name=".service.MessageService" android:enabled="true" android:exported="true" android:process=":remote" /&gt; &lt;/application&gt;&lt;/manifest&gt; 开启多进程的方法很简单，只需要给四大组件指定android:process标签。 1.2 绑定MessageService到MainActivity创建MessageService此时的MessageService就是刚创建的模样，onBind中返回了null，下一步中我们将返回一个可操作的对象给客户端。 1234567891011public class MessageService extends Service &#123; public MessageService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 客户端MainActivity调用bindService方法绑定MessageService这一步其实是属于Service组件相关的知识，在这里就比较简单地说一下，启动服务可以通过以下两种方式： 使用bindService方法 -&gt; bindService(Intent service, ServiceConnection conn, int flags)； 使用startService方法 -&gt; startService(Intent service); bindService &amp; startService区别：使用bindService方式，多个Client可以同时bind一个Service，但是当所有Client unbind后，Service会退出，通常情况下，如果希望和Service交互，一般使用bindService方法，使用onServiceConnected中的IBinder对象可以和Service进行交互，不需要和Service交互的情况下，使用startService方法即可。 正如上面所说，我们是要和Service交互的，所以我们需要使用bindService方法，但是我们希望unbind后Service仍保持运行，这样的情况下，可以同时调用bindService和startService（比如像本例子中的消息服务，退出UI进程，Service仍需要接收到消息），代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setupService(); &#125; /** * unbindService */ @Override protected void onDestroy() &#123; unbindService(serviceConnection); super.onDestroy(); &#125; /** * bindService &amp; startService */ private void setupService() &#123; Intent intent = new Intent(this, MessageService.class); bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE); startService(intent); &#125; ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG, "onServiceConnected"); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(TAG, "onServiceDisconnected"); &#125; &#125;;&#125; Stpe2.服务端在onBind方法返回Binder对象2.1 首先，什么是Binder?要说Binder，首先要说一下IBinder这个接口，IBinder是远程对象的基础接口，轻量级的远程过程调用机制的核心部分，该接口描述了与远程对象交互的抽象协议，而Binder实现了IBinder接口，简单说，Binder就是Android SDK中内置的一个多进程通讯实现类，在使用的时候，我们不用也不要去实现IBinder，而是继承Binder这个类即可实现多进程通讯。 2.2 其次，这个需要在onBind方法返回的Binder对象从何而来？在这里就要引出本文中的主题了——AIDL多进程中使用的Binder对象，一般通过我们定义好的 .adil 接口文件自动生成，当然你可以走野路子，直接手动编写这个跨进程通讯所需的Binder类，其本质无非就是一个继承了Binder的类，鉴于野路子走起来麻烦，而且都是重复步骤的工作，Google提供了 AIDL 接口来帮我们自动生成Binder这条正路，下文中我们围绕 AIDL 这条正路继续展开讨论（可不能把人给带偏了是吧🙃） 2.3 定义AIDL接口很明显，接下来我们需要搞一波上面说的Binder，让客户端可以调用到服务端的方法，而这个Binder又是通过AIDL接口自动生成，那我们就先从AIDL搞起，搞之前先看看注意事项，以免出事故： AIDL支持的数据类型： Java 编程语言中的所有基本数据类型（如 int、long、char、boolean 等等） String和CharSequence Parcelable：实现了Parcelable接口的对象 List：其中的元素需要被AIDL支持，另一端实际接收的具体类始终是 ArrayList，但生成的方法使用的是 List 接口 Map：其中的元素需要被AIDL支持，包括 key 和 value，另一端实际接收的具体类始终是 HashMap，但生成的方法使用的是 Map 接口 其他注意事项： 在AIDL中传递的对象，必须实现Parcelable序列化接口； 在AIDL中传递的对象，需要在类文件相同路径下，创建同名、但是后缀为.aidl的文件，并在文件中使用parcelable关键字声明这个类； 跟普通接口的区别：只能声明方法，不能声明变量； 所有非基础数据类型参数都需要标出数据走向的方向标记。可以是 in、out 或 inout，基础数据类型默认只能是 in，不能是其他方向。 下面继续我们的例子，开始对AIDL的讲解~ 2.4 创建一个AIDL接口，接口中提供发送消息的方法（Android Studio创建AIDL：项目右键 -&gt; New -&gt; AIDL -&gt; AIDL File），代码如下：123456package com.example.aidl;import com.example.aidl.data.MessageModel;interface MessageSender &#123; void sendMessage(in MessageModel messageModel);&#125; 一个比较尴尬的事情，看了很多文章，从来没有一篇能说清楚in、out、inout这三个参数方向的意义，后来在stackoverflow上找到比较能理解的答案（stackoverflow原文链接），我翻译一下大概意思：被“in”标记的参数，就是接收实际数据的参数，这个跟我们普通参数传递一样的含义。在AIDL中，“out” 指定了一个仅用于输出的参数，换而言之，这个参数不关心调用方传递了什么数据过来，但是这个参数的值可以在方法被调用后填充（无论调用方传递了什么值过来，在方法执行的时候，这个参数的初始值总是空的），这就是“out”的含义，仅用于输出。而“inout”显然就是“in”和“out”的合体了，输入和输出的参数。区分“in”、“out”有什么用？这是非常重要的，因为每个参数的内容必须编组（序列化，传输，接收和反序列化）。in/out标签允许Binder跳过编组步骤以获得更好的性能。 上述的MessageModel为消息的实体类，该类在AIDL中传递，实现了Parcelable序列化接口，代码如下： 12345678910111213141516171819public class MessageModel implements Parcelable &#123; private String from; private String to; private String content; ... Setter &amp; Getter ... @Override public int describeContents() &#123; return 0; &#125; //... 序列化相关代码 //...&#125; 手动实现Parcelable接口比较麻烦，安利一款AS自动生成插件android-parcelable-intellij-plugin创建完MessageModel这个实体类，别忘了还有一件事要做：”在AIDL中传递的对象，需要在类文件相同路径下，创建同名、但是后缀为.aidl的文件，并在文件中使用parcelable关键字声明这个类“。代码如下： 123package com.example.aidl.data;parcelable MessageModel; 对于没有接触过aidl的同学，光说就能让人懵逼，来看看此时的项目结构压压惊：我们刚刚新增的3个文件： MessageSender.aidl -&gt; 定义了发送消息的方法，会自动生成名为MessageSender.Stub的Binder类，在服务端实现，返回给客户端调用 MessageModel.java -&gt; 消息实体类，由客户端传递到服务端，实现了Parcelable序列化 MessageModel.aidl -&gt; 声明了MessageModel可在AIDL中传递，放在跟MessageModel.java相同的包路径下 OK，相信此时懵逼已解除~ 2.5 在服务端创建MessageSender.aidl这个AIDL接口自动生成的Binder对象，并返回给客户端调用，服务端MessageService代码如下：123456789101112131415161718192021public class MessageService extends Service &#123; private static final String TAG = "MessageService"; public MessageService() &#123; &#125; IBinder messageSender = new MessageSender.Stub() &#123; @Override public void sendMessage(MessageModel messageModel) throws RemoteException &#123; Log.d(TAG, "messageModel: " + messageModel.toString()); &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; return messageSender; &#125;&#125; MessageSender.Stub是Android Studio根据我们MessageSender.aidl文件自动生成的Binder对象（至于是怎样生成的，下文会有答案），我们需要把这个Binder对象返回给客户端。 2.6 客户端拿到Binder对象后调用远程方法调用步骤如下： 在客户端的onServiceConnected方法中，拿到服务端返回的Binder对象； 使用MessageSender.Stub.asInterface方法，取得MessageSender.aidl对应的操作接口； 取得MessageSender对象后，像普通接口一样调用方法即可。 此时客户端代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; private MessageSender messageSender; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setupService(); &#125; //... private void setupService() &#123; Intent intent = new Intent(this, MessageService.class); bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE); startService(intent); &#125; ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //使用asInterface方法取得AIDL对应的操作接口 messageSender = MessageSender.Stub.asInterface(service); //生成消息实体对象 MessageModel messageModel = new MessageModel(); messageModel.setFrom("client user id"); messageModel.setTo("receiver user id"); messageModel.setContent("This is message content"); //调用远程Service的sendMessage方法，并传递消息实体对象 try &#123; messageSender.sendMessage(messageModel); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;;&#125; 在客户端中我们调用了MessageSender的sendMessage方法，向服务端发送了一条消息，并把生成的MessageModel对象作为参数传递到了服务端，最终服务端打印的结果如下： 这里有两点要说： 服务端已经接收到客户端发送过来的消息，并正确打印； 服务端和客户端区分两个进程，PID不一样，进程名也不一样； 到这里，我们已经完成了最基本的使用AIDL进行跨进程方法调用，也是Step.0的整个细化过程，可以再回顾一下Step.0，既然已经学会使用了，接下来…全剧终。。。 如果写到这里全剧终，那跟咸鱼有什么区别… 知其然，知其所以然。我们通过上述的调用流程，看看从客户端到服务端，都经历了些什么事，看看Binder的上层是如何工作的，至于Binder的底层，这是一个非常复杂的话题，本文不深究。（如果看到这里你又想问什么是Binder的话，请手动倒带往上看…） 我们先来回顾一下从客户端发起的调用流程： MessageSender messageSender = MessageSender.Stub.asInterface(service); messageSender.sendMessage(messageModel); 抛开其它无关代码，客户端调跨进程方法就这两个步骤，而这两个步骤都封装在 MessageSender.aidl 最终生成的 MessageSender.java 源码（具体路径为：build目录下某个子目录，自己找，不爽你来打我啊 😋 ） 请看下方代码和注释，前方高能预警… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public interface MessageSender extends android.os.IInterface &#123; public static abstract class Stub extends android.os.Binder implements com.example.aidl.MessageSender &#123; private static final java.lang.String DESCRIPTOR = "com.example.aidl.MessageSender"; /** * 把IBinder对象转换为 com.example.aidl.MessageSender 接口 * 判断IBinder是否处于相同进程，相同进程返回Stub实现的com.example.aidl.MessageSender接口 * 不同进程，则返回Stub.Proxy实现的com.example.aidl.MessageSender接口 */ public static com.example.aidl.MessageSender asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.aidl.MessageSender))) &#123; return ((com.example.aidl.MessageSender) iin); &#125; return new com.example.aidl.MessageSender.Stub.Proxy(obj); &#125; /** * 同一进程时，不会触发 * * 不同进程时，asInterface会返回Stub.Proxy，客户端调用 messageSender.sendMessage(messageModel) * 实质是调用了 Stub.Proxy 的 sendMessage 方法，从而触发跨进程数据传递， * 最终Binder底层将处理好的数据回调到此方法，并调用我们真正的sendMessage方法 */ @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_sendMessage: &#123; data.enforceInterface(DESCRIPTOR); com.example.aidl.data.MessageModel _arg0; if ((0 != data.readInt())) &#123; _arg0 = com.example.aidl.data.MessageModel.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.sendMessage(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.example.aidl.MessageSender &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; /** * Proxy中的sendMessage方法，并不是直接调用我们定义的sendMessage方法，而是经过一顿的Parcel读写， * 然后调用mRemote.transact方法，把数据交给Binder处理，transact处理完毕后会调用上方的onTransact方法， * onTransact拿到最终得到的参数数据，调用由我们真正的sendMessage方法 */ @Override public void sendMessage(com.example.aidl.data.MessageModel messageModel) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((messageModel != null)) &#123; _data.writeInt(1); messageModel.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; //调用Binder的transact方法进行多进程数据传输，处理完毕后调用上方的onTransact方法 mRemote.transact(Stub.TRANSACTION_sendMessage, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_sendMessage = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); &#125; public void sendMessage(com.example.aidl.data.MessageModel messageModel) throws android.os.RemoteException;&#125; 只看代码的话，可能会有点懵逼，相信结合代码再看下方的流程图会更好理解： 从客户端的sendMessage开始，整个AIDL的调用过程如上图所示，asInterface方法，将会判断onBind方法返回的Binder是否存处于同一进程，在同一进程中，则进行常规的方法调用，若处于不同进程，整个数据传递的过程则需要通过Binder底层去进行编组（序列化，传输，接收和反序列化），得到最终的数据后再进行常规的方法调用。 敲黑板：对象跨进程传输的本质就是 序列化，传输，接收和反序列化 这样一个过程，这也是为什么跨进程传输的对象必须实现Parcelable接口 跨进程的回调接口在上面我们已经实现了从客户端发送消息到跨进程服务端的功能，接下来我们还需要将服务端接收到的远程服务器消息，传递到客户端。有同学估计会说：“这不就是一个回调接口的事情嘛”，设置回调接口思路是对的，但是在这里使用的回调接口有点不一样，在AIDL中传递的接口，不能是普通的接口，只能是AIDL接口，所以我们需要新建一个AIDL接口传到服务端，作为回调接口。 新建消息收取的AIDL接口MessageReceiver.aidl： 123456package com.example.aidl;import com.example.aidl.data.MessageModel;interface MessageReceiver &#123; void onMessageReceived(in MessageModel receivedMessage);&#125; 接下来我们把回调接口注册到服务端去，修改我们的MessageSender.aidl: 1234567891011package com.example.aidl;import com.example.aidl.data.MessageModel;import com.example.aidl.MessageReceiver;interface MessageSender &#123; void sendMessage(in MessageModel messageModel); void registerReceiveListener(MessageReceiver messageReceiver); void unregisterReceiveListener(MessageReceiver messageReceiver);&#125; 以上就是我们最终修改好的aidl接口，接下来我们需要做出对应的变更： 在服务端中增加MessageSender的注册和反注册接口的方法； 在客户端中实现MessageReceiver接口，并通过MessageSender注册到服务端。 客户端变更，修改MainActivity： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; private MessageSender messageSender; @Override protected void onCreate(Bundle savedInstanceState) &#123; //... &#125; /** * 1.unregisterListener * 2.unbindService */ @Override protected void onDestroy() &#123; //解除消息监听接口 if (messageSender != null &amp;&amp; messageSender.asBinder().isBinderAlive()) &#123; try &#123; messageSender.unregisterReceiveListener(messageReceiver); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; unbindService(serviceConnection); super.onDestroy(); &#125; //消息监听回调接口 private MessageReceiver messageReceiver = new MessageReceiver.Stub() &#123; @Override public void onMessageReceived(MessageModel receivedMessage) throws RemoteException &#123; Log.d(TAG, "onMessageReceived: " + receivedMessage.toString()); &#125; &#125;; ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //使用asInterface方法取得AIDL对应的操作接口 messageSender = MessageSender.Stub.asInterface(service); //生成消息实体对象 MessageModel messageModel = new MessageModel(); //... try &#123; //把接收消息的回调接口注册到服务端 messageSender.registerReceiveListener(messageReceiver); //调用远程Service的sendMessage方法，并传递消息实体对象 messageSender.sendMessage(messageModel); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;;&#125; 客户端主要有3个变更： 增加了messageReceiver对象，用于监听服务端的消息通知； onServiceConnected方法中，把messageReceiver注册到Service中去； onDestroy时候解除messageReceiver的注册。 下面对服务端MessageServie进行变更： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class MessageService extends Service &#123; private static final String TAG = "MessageService"; private AtomicBoolean serviceStop = new AtomicBoolean(false); //RemoteCallbackList专门用来管理多进程回调接口 private RemoteCallbackList&lt;MessageReceiver&gt; listenerList = new RemoteCallbackList&lt;&gt;(); public MessageService() &#123; &#125; IBinder messageSender = new MessageSender.Stub() &#123; @Override public void sendMessage(MessageModel messageModel) throws RemoteException &#123; Log.e(TAG, "messageModel: " + messageModel.toString()); &#125; @Override public void registerReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123; listenerList.register(messageReceiver); &#125; @Override public void unregisterReceiveListener(MessageReceiver messageReceiver) throws RemoteException &#123; listenerList.unregister(messageReceiver); &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; return messageSender; &#125; @Override public void onCreate() &#123; super.onCreate(); new Thread(new FakeTCPTask()).start(); &#125; @Override public void onDestroy() &#123; serviceStop.set(true); super.onDestroy(); &#125; //模拟长连接，通知客户端有新消息到达 private class FakeTCPTask implements Runnable &#123; @Override public void run() &#123; while (!serviceStop.get()) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; MessageModel messageModel = new MessageModel(); messageModel.setFrom("Service"); messageModel.setTo("Client"); messageModel.setContent(String.valueOf(System.currentTimeMillis())); /** * RemoteCallbackList的遍历方式 * beginBroadcast和finishBroadcast一定要配对使用 */ final int listenerCount = listenerList.beginBroadcast(); Log.d(TAG, "listenerCount == " + listenerCount); for (int i = 0; i &lt; listenerCount; i++) &#123; MessageReceiver messageReceiver = listenerList.getBroadcastItem(i); if (messageReceiver != null) &#123; try &#123; messageReceiver.onMessageReceived(messageModel); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; listenerList.finishBroadcast(); &#125; &#125; &#125;&#125; 服务端主要变更： MessageSender.Stub实现了注册和反注册回调接口的方法； 增加了RemoteCallbackList来管理AIDL远程接口； FakeTCPTask模拟了长连接通知客户端有新消息到达。（这里的长连接可以是XMPP，Mina，Mars，Netty等，这里弄个假的意思意思，有时间的话咱开个帖子聊聊XMPP） 这里还有一个需要讲一下的，就是RemoteCallbackList，为什么要用RemoteCallbackList，普通ArrayList不行吗？当然不行，不然干嘛又整一个RemoteCallbackList 🙃，registerReceiveListener 和 unregisterReceiveListener在客户端传输过来的对象，经过Binder处理，在服务端接收到的时候其实是一个新的对象，这样导致在 unregisterReceiveListener 的时候，普通的ArrayList是无法找到在 registerReceiveListener 时候添加到List的那个对象的，但是它们底层使用的Binder对象是同一个，RemoteCallbackList利用这个特性做到了可以找到同一个对象，这样我们就可以顺利反注册客户端传递过来的接口对象了。RemoteCallbackList在客户端进程终止后，它能自动移除客户端所注册的listener，它内部还实现了线程同步，所以我们在注册和反注册都不需要考虑线程同步，的确是个666的类。（至于使用ArrayList的幺蛾子现象，大家可以自己试试，篇幅问题，这里就不演示了） 到此，服务端通知客户端相关的代码也写完了，运行结果无非就是正确打印🙃就不贴图了，可以自己Run一下，打印的时候注意去选择不同的进程，不然瞪坏屏幕也没有日志。 DeathRecipient你以为这样就完了？too young too simple… 不知道你有没有感觉到，两个进程交互总是觉得缺乏那么一点安全感…比如说服务端进程Crash了，而客户端进程想要调用服务端方法，这样就调用不到了。此时我们可以给Binder设置一个DeathRecipient对象，当Binder意外挂了的时候，我们可以在DeathRecipient接口的回调方法中收到通知，并作出相应的操作，比如重连服务等等。 DeathRecipient的使用如下： 声明DeathRecipient对象，实现其binderDied方法，当binder死亡时，会回调binderDied方法； 给Binder对象设置DeathRecipient对象。 在客户端MainActivity声明DeathRecipient： 12345678910111213141516171819202122232425262728293031/** * Binder可能会意外死忙（比如Service Crash），Client监听到Binder死忙后可以进行重连服务等操作 */ IBinder.DeathRecipient deathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; Log.d(TAG, "binderDied"); if (messageSender != null) &#123; messageSender.asBinder().unlinkToDeath(this, 0); messageSender = null; &#125; //// TODO: 2017/2/28 重连服务或其他操作 setupService(); &#125; &#125;; ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //... try &#123; //设置Binder死亡监听 messageSender.asBinder().linkToDeath(deathRecipient, 0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; //... &#125;; Binder中两个重要方法： linkToDeath -&gt; 设置死亡代理 DeathRecipient 对象； unlinkToDeath -&gt; Binder死亡的情况下，解除该代理。 此外，Binder中的isBinderAlive也可以判断Binder是否死亡。 权限验证就算是公交车，上车也得嘀卡对不，如果希望我们的服务进程不想像公交车一样谁想上就上，那么我们可以加入权限验证。 介绍两种常用验证方法： 在服务端的onBind中校验自定义permission，如果通过了我们的校验，正常返回Binder对象，校验不通过返回null，返回null的情况下客户端无法绑定到我们的服务； 在服务端的onTransact方法校验客户端包名，不通过校验直接return false，校验通过执行正常的流程。 自定义permission，在Androidmanifest.xml中增加自定义的权限： 12345&lt;permission android:name="com.example.aidl.permission.REMOTE_SERVICE_PERMISSION" android:protectionLevel="normal" /&gt;&lt;uses-permission android:name="com.example.aidl.permission.REMOTE_SERVICE_PERMISSION" /&gt; 服务端检查权限的方法： 12345678910111213141516171819202122232425262728293031IBinder messageSender = new MessageSender.Stub() &#123; //... @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; /** * 包名验证方式 */ String packageName = null; String[] packages = getPackageManager().getPackagesForUid(getCallingUid()); if (packages != null &amp;&amp; packages.length &gt; 0) &#123; packageName = packages[0]; &#125; if (packageName == null || !packageName.startsWith("com.example.aidl")) &#123; Log.d("onTransact", "拒绝调用：" + packageName); return false; &#125; return super.onTransact(code, data, reply, flags); &#125;&#125;;@Overridepublic IBinder onBind(Intent intent) &#123; //自定义permission方式检查权限 if (checkCallingOrSelfPermission("com.example.aidl.permission.REMOTE_SERVICE_PERMISSION") == PackageManager.PERMISSION_DENIED) &#123; return null; &#125; return messageSender;&#125; 根据不同进程，做不同的初始化工作相信前一两年很多朋友还在使用Android-Universal-Image-Loader来加载图片，它是需要在Application类进行初始化的。打个比如，我们用它来加载图片，而且还有一个图片选择进程，那么我们希望分配更多的缓存给图片选择进程，又或者是一些其他的初始化工作，不需要在图片选择进程初始化怎么办？ 这里提供一个简单粗暴的方法，博主也是这么干的…直接拿到进程名判断，作出相应操作即可： 123456789101112131415161718192021222324public class MyApp extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); Log.d("process name", getProcessName()); &#125; //取得进程名 private String getProcessName() &#123; ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; runningApps = am.getRunningAppProcesses(); if (runningApps == null) &#123; return null; &#125; for (ActivityManager.RunningAppProcessInfo procInfo : runningApps) &#123; if (procInfo.pid == Process.myPid()) &#123; return procInfo.processName; &#125; &#125; return null; &#125;&#125; 每个进程创建，都会调用Application的onCreate方法，这是一个需要注意的地方，我们也可以根据当前进程的pid，拿到当前进程的名字去做判断，然后做一些我们需要的逻辑，我们这个例子，拿到的两个进程名分别是： 客户端进程：com.example.aidl 服务端进程：com.example.aidl:remote 总结 多进程app可以在系统中申请多份内存，但应合理使用，建议把一些高消耗但不常用的模块放到独立的进程，不使用的进程可及时手动关闭； 实现多进程的方式有多种：四大组件传递Bundle、Messenger、AIDL等，选择适合自己的使用场景； Android中实现多进程通讯，建议使用系统提供的Binder类，该类已经实现了多进程通讯而不需要我们做底层工作； 多进程应用，Application将会被创建多次； 结语这篇文章断断续续写了很久，而且我相信真正使用起来的同学可能不多，选择这样一个话题我是吃力不讨好… 但是我还是希望可以在这里提供一个完整的解决方案给大家。简单的多进程使用，而且效果显著的，比如把图片选择和WebView配置到独立的进程，这个我希望可以大家行动起来。这篇文章的知识点非常多，理解起来可能不是太容易，如果有兴趣，我建议你手动去写一下，然后不理解的地方，打断点看看是什么样的运行步骤。 对于面试的同学，如果在面试过程中说到多进程，跟面试官聊得开，估计也是能加点分的，或者在实际工作中，一些使用多进程可以更好地解决问题的地方，你可以在会议中拍桌猛起，跟主管说：“我有一个大胆的想法…”，这样装逼也不错（当然，被炒了的话就不关我的事了…）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>实践应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于有多种可替代解决方案的业务逻辑，提供一种快速更换的思路]]></title>
    <url>%2F2016%2F12%2F11%2F%E8%A7%A3%E8%80%A6%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[什么是“有多种可替代解决方案的业务逻辑”？举几个例子说明： 客户端的http请求操作，可以实现的方案有Retrofit、OkHttp、Volley等； 客户端的数据库存储方案可以为Realm、greenDao、OrmLite等； 图片加载的方案可以是Fresco、Glide、Picasso、UIL等。 如何快速替换？先来描述一下需求，比如说，目前正在用的http请求是Volley，现在发现使用OkHttp来封装一套会更好。又比方说，目前正在用的数据存储方案是OrmLite，现在使用greenDao或者Realm会更好，在类似这些情况下，如何做到不修改Activity/Fragment/Presenter代码的情况下，把Volley的http请求实现更换成Okhttp的实现，把OrmLite更换成greenDao或者Realm？ 解决问题的关键词：设计模式中的——工厂方法模式。本质：利用接口进行解耦。 说到这里，可能很多有经验的朋友已经会心一笑，是的，老实说这篇文章可能对老司机没有太大的意义，但是如果看到这里还是心存疑问，或者你不知道什么是工厂方法模式，也不知道如何使用接口解耦什么的，没关系，请继续往下看。 Talk is cheap, show me the code.下面，我们就用Volley更换到OkHttp这个例子来说明一下如何做到不修改Activity/Fragment/Presenter的代码情况下，更快地更换业务逻辑实现的代码。 在开始之前先来思考一下上述所说“可替代解决方案”的含义，为何这些方案是可替代的？是因为它们具有相同的共性，它们所要解决的问题是相同的，比如说http请求框架，无论是Volley/OkHttp/Retrofit，它们所要实现的都是http请求中的get/post/put/delete这些方法，数据库存储框架中无论是Realm/greenDao/OrmLite，它们要实现的都是增删改查这些方法。 “博主你别再瞎逼逼，赶紧说重点…”我：dalao我错了，下面说重点… 先来概括一下我们的实现思路： 把http请求框架的共性方法抽取到接口中，我们把这个接口称为“请求接口”； 创建一个用于返回请求结果的接口，我们把这个接口称为“回调接口”； 分别用Volley和OkHttp实现“请求接口”； 创建一个类来返回上述接口的对象，我们把这个类叫做“工厂”类； 在Activity/Fragment/Presenter中，使用“工厂”返回的这个接口对象调用get/post/put/delete方法，并在“回调接口”中得到请求结果。 本文完整代码https://github.com/V1sk/HttpRequestExample，可以先clone到本地再看文章，为了方便阅读，下文中的代码将省略非重点部分。 Step1：把http请求框架的共性方法抽取到接口中（也就是上述说的get/post/put/delete这些方法）1234567891011121314151617/* * 此接口提供的就是http请求通用的方法，该接口可以用Volley来实现，也能用OkHttp等其它方式来实现 * 接口说明： * get方法参数包含一个url，以及返回数据的接口 * post/put/delete方法还需要提供一个请求体参数 */public interface IRequestManager &#123; void get(String url, IRequestCallback requestCallback); void post(String url, String requestBodyJson, IRequestCallback requestCallback); void put(String url, String requestBodyJson, IRequestCallback requestCallback); void delete(String url, String requestBodyJson, IRequestCallback requestCallback);&#125; 上面的IRequestManager接口中用到的请求结果回调接口——IRequestCallback 12345678910111213/** * Created by chenjianwei on 2016/12/11. * 请求返回成功/失败，成功时，把服务器返回的结果回调出去，失败时回调异常信息 * onSuccess中的参数类型，当然也可以为JSONObject，这里只是举个栗子，可按照实际需求变通 */public interface IRequestCallback &#123; void onSuccess(String response); void onFailure(Throwable throwable);&#125; 至此，我们已经把数据请求的接口，以及数据返回的接口都定义好了，整理一下思绪 首先我们搞清楚http请求，有哪些方法，需要有哪些参数——IRequestManager； 数据返回会有什么情况？——IRequestCallback； Step2:用Volley来实现IRequestManager这个接口.12345678910111213141516171819202122232425262728293031323334353637383940public class VolleyRequestManager implements IRequestManager &#123; ... @Override public void get(String url, final IRequestCallback requestCallback) &#123; StringRequest request = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String s) &#123; requestCallback.onSuccess(s); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError volleyError) &#123; requestCallback.onFailure(volleyError); &#125; &#125;); HttpRequestExampleApp.mQueue.add(request); &#125; @Override public void post(String url, String requestBodyJson, final IRequestCallback requestCallback) &#123; requestWithBody(url, requestBodyJson, requestCallback, Request.Method.POST); &#125; @Override public void put(String url, String requestBodyJson, final IRequestCallback requestCallback) &#123; requestWithBody(url, requestBodyJson, requestCallback, Request.Method.PUT); &#125; @Override public void delete(String url, String requestBodyJson, final IRequestCallback requestCallback) &#123; requestWithBody(url, requestBodyJson, requestCallback, Request.Method.DELETE); &#125; ...&#125; VolleyRequestManager实现了IRequestManager接口，到这里我想你也看出来可以使用VolleyRequestManager来进行get/post/put/delete操作了，是的，已经可以用于请求操作，但是我们先不这样做，原因请继续往下看Step3。 Step3：创建一个类来返回IRequestManager请求接口的对象1234567891011121314/* * 该类的作用是用于返回一个IRequestManager对象，这个IRequestManager的实现类 * 可以是使用Volley实现的http请求对象，也可以是OkHttp实现的http请求对象 * Activity/Fragment/Presenter中，只要调用getRequestManager()方法就能得到 * http请求的操作接口，而不用关心具体是使用什么实现的。 */public class RequestFactory &#123; public static IRequestManager getRequestManager()&#123; return VolleyRequestManager.getInstance(); //return OkHttpRequestManager.getInstance(); &#125; &#125; 到这里，请容许我再逼逼一下，为什么要用这种方法来返回对象，而不直接在Activity/Fragment/Presenter中创建VolleyRequestManager对象来进行操作？如果直接在Activity/Fragment/Presenter中使用VolleyRequestManager来创建对象，你的代码就依赖了VolleyRequestManager，这种情况下，如果要更换成OkHttp，岂不是要把代码中所有的VolleyRequestManager对象也更换成OkHttp的请求对象？再试想一下，如果你有很多个Activity/Fragment/Presenter使用了VolleyRequestManager对象，你是不是要每个地方都更换一遍？ 使用RequestFactory的方式在Activity/Fragment/Presenter中创建对象，代码只依赖了IRequestManager这个接口，这就是使用接口进行解耦的关键点，无论在什么地方使用了这个接口，当要更换实现的时候，只需要修改RequestFactory中return的实现类就可以了。 Step4:调用上述方法进行测试1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //请求测试url String url = "https://api.douban.com/v2/movie/top250"; //这里发起请求依赖的是IRequestManager接口，而没有具体实现类代码出现在这里 IRequestManager requestManager = RequestFactory.getRequestManager(); //调用接口的get方法 requestManager.get(url, new IRequestCallback() &#123; @Override public void onSuccess(String response) &#123; Log.d(TAG, "onSuccess: " + response); //// TODO: 2016/12/11 your code &#125; @Override public void onFailure(Throwable throwable) &#123; throwable.printStackTrace(); //// TODO: 2016/12/11 your code &#125; &#125;); &#125;&#125; 注意我们创建请求对象的代码，这里没有出现具体的实现类：IRequestManager requestManager = RequestFactory.getRequestManager(); Step5:不更改MainActivity中任何代码，把Http请求的逻辑替换成OkHttp来实现1）先用OkHttp来实现IRequestManager这个接口. 123456789101112131415161718192021222324252627282930313233343536public class OkHttpRequestManager implements IRequestManager &#123; ... @Override public void get(String url, IRequestCallback requestCallback) &#123; Request request = new Request.Builder() .url(url) .get() .build(); addCallBack(requestCallback, request); &#125; @Override public void post(String url, String requestBodyJson, IRequestCallback requestCallback) &#123; RequestBody body = RequestBody.create(TYPE_JSON, requestBodyJson); Request request = new Request.Builder() .url(url) .post(body) .build(); addCallBack(requestCallback, request); &#125; @Override public void put(String url, String requestBodyJson, IRequestCallback requestCallback) &#123; ... &#125; @Override public void delete(String url, String requestBodyJson, IRequestCallback requestCallback) &#123; ... &#125; ... &#125; 2) 使用OkHttp更换Volley现在我们用OkHttp的请求方式也实现了一套get/post/put/delete的请求方法，此时只要修改Step3中，返回的对象为OkHttpRequestManager对象，就已经完成了我们整个http请求框架的更换，此时，你可以完全移除Volley的引用以及代码，而不会对程序有任何影响。 总结：对于有多种可替代解决方案的业务逻辑，我的解耦思路是这样的： 抽取它们的共性方法到接口中； 使用自己选择的实现方案去实现； 使用“工厂”类把具体实现转换成抽象接口，并返回抽象接口对象； Activity/Fragment/Presenter中，使用“工厂”中返回的接口进行操作，而不要依赖于其实现类。 要更换方案的时候，只需要修改“工厂”中返回的实现类。 后记这篇文章只是提供一种解耦思想，而不是“如何封装http请求框架”的教程，也不是讨论“哪个http请求框架好用”的文章，当然，你完全可以用这种方法进行http请求的封装。然后，这篇文章是博主的第一篇文章，可能写得不是很好，欢迎大家提出宝贵意见。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎阅读]]></title>
    <url>%2F2016%2F06%2F19%2FWelcome%2F</url>
    <content type="text"><![CDATA[欢迎阅读你好，我是一位Android开发工程师，三年工作经验。我的博客最主要的用途是用于分享我个人对技术的观点以及经验，我希望这些内容可以帮助到有需要的人，同时，也希望通过写作，来提高自己对技术的理解。一起加油！！]]></content>
  </entry>
</search>
